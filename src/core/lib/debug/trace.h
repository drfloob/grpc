// Copyright 2015 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//
// Automatically generated by tools/codegen/core/gen_trace_flags.py
//

#ifndef GRPC_SRC_CORE_LIB_DEBUG_TRACE_H
#define GRPC_SRC_CORE_LIB_DEBUG_TRACE_H

#include <atomic>
#include <map>
#include <string>

#include "absl/container/flat_hash_map.h"
#include "absl/log/log.h"
#include "absl/strings/string_view.h"

#include <grpc/support/port_platform.h>

void grpc_tracer_init();
void grpc_tracer_shutdown(void);

namespace grpc_core {
bool ParseTracers(absl::string_view tracers);
class SavedTraceFlags;

class TraceFlag;

namespace testing {
void grpc_tracer_enable_flag(TraceFlag* flag);
}

class TraceFlag {
 public:
  TraceFlag(bool default_enabled, const char* name);
  // TraceFlag needs to be trivially destructible since it is used as global
  // variable.
  ~TraceFlag() = default;

  const char* name() const { return name_; }

// Use the symbol GRPC_USE_TRACERS to determine if tracers will be enabled in
// opt builds (tracers are always on in dbg builds). The default in OSS is for
// tracers to be on since we support binary distributions of gRPC for the
// wrapped language (wr don't want to force recompilation to get tracing).
// Internally, however, for performance reasons, we compile them out by
// default, since internal build systems make recompiling trivial.
//
// Prefer GRPC_TRACE_FLAG_ENABLED() macro instead of using enabled() directly.
#define GRPC_USE_TRACERS  // tracers on by default in OSS
#if defined(GRPC_USE_TRACERS) || !defined(NDEBUG)
  bool enabled() { return value_.load(std::memory_order_relaxed); }
#else
  bool enabled() { return false; }
#endif  // defined(GRPC_USE_TRACERS) || !defined(NDEBUG)

 private:
  friend void testing::grpc_tracer_enable_flag(TraceFlag* flag);
  friend bool ParseTracers(absl::string_view tracers);
  friend SavedTraceFlags;

  void set_enabled(bool enabled) {
    value_.store(enabled, std::memory_order_relaxed);
  }

  TraceFlag* next_tracer_;
  const char* const name_;
  std::atomic<bool> value_;
};

#define GRPC_TRACE_FLAG_ENABLED(f) GPR_UNLIKELY((f).enabled())
#define GRPC_TRACE_LOG(tracer, level) \
  LOG_IF(level, GRPC_TRACE_FLAG_ENABLED(grpc_core::tracer##_trace))

#ifndef NDEBUG
typedef TraceFlag DebugOnlyTraceFlag;
#else
class DebugOnlyTraceFlag {
 public:
  constexpr DebugOnlyTraceFlag(bool /*default_enabled*/, const char* /*name*/) {
  }
  constexpr bool enabled() const { return false; }
  constexpr const char* name() const { return "DebugOnlyTraceFlag"; }

 private:
  void set_enabled(bool /*enabled*/) {}
};
#endif

class SavedTraceFlags {
 public:
  SavedTraceFlags();
  void Restore();

 private:
  std::map<std::string, std::pair<bool, TraceFlag*>> values_;
};

extern DebugOnlyTraceFlag auth_context_refcount_trace;
extern DebugOnlyTraceFlag call_combiner_trace;
extern DebugOnlyTraceFlag call_refcount_trace;
extern DebugOnlyTraceFlag closure_trace;
extern DebugOnlyTraceFlag combiner_trace;
extern DebugOnlyTraceFlag cq_refcount_trace;
extern DebugOnlyTraceFlag error_refcount_trace;
extern DebugOnlyTraceFlag fd_refcount_trace;
extern DebugOnlyTraceFlag fd_trace_trace;
extern DebugOnlyTraceFlag lb_policy_refcount_trace;
extern DebugOnlyTraceFlag party_state_trace;
extern DebugOnlyTraceFlag pending_tags_trace;
extern DebugOnlyTraceFlag polling_trace;
extern DebugOnlyTraceFlag polling_api_trace;
extern DebugOnlyTraceFlag promise_primitives_trace;
extern DebugOnlyTraceFlag resolver_refcount_trace;
extern DebugOnlyTraceFlag security_connector_refcount_trace;
extern DebugOnlyTraceFlag slice_refcount_trace;
extern DebugOnlyTraceFlag stream_refcount_trace;
extern DebugOnlyTraceFlag subchannel_refcount_trace;
extern DebugOnlyTraceFlag work_serializer_trace;
extern TraceFlag api_trace;
extern TraceFlag backend_metric_trace;
extern TraceFlag backend_metric_filter_trace;
extern TraceFlag bdp_estimator_trace;
extern TraceFlag call_trace;
extern TraceFlag call_error_trace;
extern TraceFlag cares_address_sorting_trace;
extern TraceFlag cares_resolver_trace;
extern TraceFlag cds_lb_trace;
extern TraceFlag channel_trace;
extern TraceFlag channel_stack_trace;
extern TraceFlag chaotic_good_trace;
extern TraceFlag chttp2_hpack_parser_trace;
extern TraceFlag chttp2_new_stream_trace;
extern TraceFlag client_channel_trace;
extern TraceFlag client_channel_call_trace;
extern TraceFlag client_channel_lb_call_trace;
extern TraceFlag client_idle_filter_trace;
extern TraceFlag compression_trace;
extern TraceFlag connectivity_state_trace;
extern TraceFlag cronet_trace;
extern TraceFlag dns_resolver_trace;
extern TraceFlag environment_autodetect_trace;
extern TraceFlag event_engine_trace;
extern TraceFlag event_engine_client_channel_resolver_trace;
extern TraceFlag event_engine_dns_trace;
extern TraceFlag event_engine_endpoint_trace;
extern TraceFlag event_engine_endpoint_data_trace;
extern TraceFlag event_engine_poller_trace;
extern TraceFlag executor_trace;
extern TraceFlag fault_injection_filter_trace;
extern TraceFlag flowctl_trace;
extern TraceFlag fork_trace;
extern TraceFlag glb_trace;
extern TraceFlag grpc_authz_api_trace;
extern TraceFlag handshaker_trace;
extern TraceFlag health_check_client_trace;
extern TraceFlag http_trace;
extern TraceFlag http1_trace;
extern TraceFlag http2_ping_trace;
extern TraceFlag http2_stream_state_trace;
extern TraceFlag http_keepalive_trace;
extern TraceFlag inproc_trace;
extern TraceFlag metadata_query_trace;
extern TraceFlag op_failure_trace;
extern TraceFlag orca_client_trace;
extern TraceFlag outlier_detection_lb_trace;
extern TraceFlag pick_first_trace;
extern TraceFlag plugin_credentials_trace;
extern TraceFlag priority_lb_trace;
extern TraceFlag queue_pluck_trace;
extern TraceFlag resource_quota_trace;
extern TraceFlag retry_trace;
extern TraceFlag ring_hash_lb_trace;
extern TraceFlag rls_lb_trace;
extern TraceFlag round_robin_trace;
extern TraceFlag secure_endpoint_trace;
extern TraceFlag server_channel_trace;
extern TraceFlag stateful_session_filter_trace;
extern TraceFlag subchannel_trace;
extern TraceFlag subchannel_pool_trace;
extern TraceFlag tcp_trace;
extern TraceFlag timer_trace;
extern TraceFlag timer_check_trace;
extern TraceFlag tsi_trace;
extern TraceFlag weighted_round_robin_lb_trace;
extern TraceFlag weighted_target_lb_trace;
extern TraceFlag xds_client_trace;
extern TraceFlag xds_client_refcount_trace;
extern TraceFlag xds_cluster_impl_lb_trace;
extern TraceFlag xds_cluster_manager_lb_trace;
extern TraceFlag xds_cluster_resource_type_test_trace;
extern TraceFlag xds_common_types_test_trace;
extern TraceFlag xds_endpoint_resource_type_test_trace;
extern TraceFlag xds_listener_resource_type_test_trace;
extern TraceFlag xds_override_host_lb_trace;
extern TraceFlag xds_resolver_trace;
extern TraceFlag xds_route_config_resource_type_test_trace;
extern TraceFlag xds_server_config_fetcher_trace;
extern TraceFlag xds_wrr_locality_lb_trace;

const absl::flat_hash_map<std::string, TraceFlag*>* GetAllTraceFlags();

constexpr const char* g_all_trace_var_names[] = {
    "api",
    "backend_metric",
    "backend_metric_filter",
    "bdp_estimator",
    "call",
    "call_error",
    "cares_address_sorting",
    "cares_resolver",
    "cds_lb",
    "channel",
    "channel_stack",
    "chaotic_good",
    "chttp2_hpack_parser",
    "chttp2_new_stream",
    "client_channel",
    "client_channel_call",
    "client_channel_lb_call",
    "client_idle_filter",
    "compression",
    "connectivity_state",
    "cronet",
    "dns_resolver",
    "environment_autodetect",
    "event_engine",
    "event_engine_client_channel_resolver",
    "event_engine_dns",
    "event_engine_endpoint",
    "event_engine_endpoint_data",
    "event_engine_poller",
    "executor",
    "fault_injection_filter",
    "flowctl",
    "fork",
    "glb",
    "grpc_authz_api",
    "handshaker",
    "health_check_client",
    "http",
    "http1",
    "http2_ping",
    "http2_stream_state",
    "http_keepalive",
    "inproc",
    "metadata_query",
    "op_failure",
    "orca_client",
    "outlier_detection_lb",
    "pick_first",
    "plugin_credentials",
    "priority_lb",
    "queue_pluck",
    "resource_quota",
    "retry",
    "ring_hash_lb",
    "rls_lb",
    "round_robin",
    "secure_endpoint",
    "server_channel",
    "stateful_session_filter",
    "subchannel",
    "subchannel_pool",
    "tcp",
    "timer",
    "timer_check",
    "tsi",
    "weighted_round_robin_lb",
    "weighted_target_lb",
    "xds_client",
    "xds_client_refcount",
    "xds_cluster_impl_lb",
    "xds_cluster_manager_lb",
    "xds_cluster_resource_type_test",
    "xds_common_types_test",
    "xds_endpoint_resource_type_test",
    "xds_listener_resource_type_test",
    "xds_override_host_lb",
    "xds_resolver",
    "xds_route_config_resource_type_test",
    "xds_server_config_fetcher",
    "xds_wrr_locality_lb",
#ifndef NDEBUG
    "auth_context_refcount",
    "call_combiner",
    "call_refcount",
    "closure",
    "combiner",
    "cq_refcount",
    "error_refcount",
    "fd_refcount",
    "fd_trace",
    "lb_policy_refcount",
    "party_state",
    "pending_tags",
    "polling",
    "polling_api",
    "promise_primitives",
    "resolver_refcount",
    "security_connector_refcount",
    "slice_refcount",
    "stream_refcount",
    "subchannel_refcount",
    "work_serializer",
#endif
};

}  // namespace grpc_core

#endif  // GRPC_SRC_CORE_LIB_DEBUG_TRACE_H
